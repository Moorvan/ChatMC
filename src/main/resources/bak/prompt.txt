vmt-lib:
Verification Modulo Theories was originally proposed in the Rich-Model Toolkit meeting held in Turin in 2011 (see slides below).
Since then, a format has been defined (see below), and is now supported by the the nuXmv model checker.
The VMT format is an extension of the SMT-LIBv2 (SMT2 for short) format to represent symbolic transition systems. VMT exploits the capability offered by the SMT2 language of attaching annotations to terms and formulas in order to specify the components of the transition system and the properties to verify.
Core language

In the core VMT-LIB language, the following annotations are used:
:next name is used to represent state variables. For each variable x in the model, the VMT file contains a pair of variables, xc and xn, representing respectively the current and next version of x. The two variables are linked by annotating xc with the attribute :next xn. All the variables that are not in relation with another by means of a :next attribute are considered inputs.
:init is used to specify the formula for the initial states of the model. This formula should contain neither next-state variables nor input variables.
:trans is used to specify the formula for the transition relation.
:invar-property idx is used to specify invariant properties, i.e. formulas of the form Gp, where p is the formula annotated with :invar-property. The non-negative integer idx is a unique identifier for the property.
:live-property idx is used to specify an LTL property of the form F Gp, where p is the formula annotated with :live-property. The non-negative integer idx is a unique identifier for the property.

In a VMT file, only annotated terms and their sub-terms are meaningful. Any other term is ignored. Moreover, only the following commands are allowed to occur in VMT files: set-logic, set-option, declare-sort, define-sort, declare-fun, define-fun (For convenience, an additional (assert true) command is allowed to appear at the end of the file).
The following example shows a simple NUXMV model and its corresponding VMT translation.

nuXmv
-- this is a comment
MODULE main
VAR x : integer;
IVAR b : boolean;
INIT x = 1;
TRANS
next(x) = b ? x + 1 : x;
INVARSPEC x > 0;
LTLSPEC FG x > 10;

VMT
; this is a comment
(declare-const x Int)
(declare-const x.next Int)
(define-fun sv.x () Int (! x :next x.next))
(declare-const b Bool)
(define-fun init () Bool (! (= x 1) :init true))
(define-fun trans () Bool
   (! (= x.next (ite b (+ x 1) x)) :trans true)
(define-fun p1 () Bool (! (> x 0) :invar-property 1))
(define-fun p2 () Bool (! (> x 10) :live-property 2))

Since the SMT2 format (and thus also the VMT one that inherits from SMT2) does not allow to annnotate the declaration of variables, it is a good practice to insert immediately after the declaration of the variables a set of defines to specify the relations among variables. See for instance the define sv0 in the example above that introduces the relation between x and xn.
Language extensions
The following annotations are not part of the core language, but are defined as syntactic sugar to model higher level constructs. They can be removed by the vmtext2core.py script that is part of the vmt-tools package (see below):
:invar is used to specify additional invariant constraints (that must always hold).
:ltl-property idx is used to specify an arbitrary LTL property, using the built-in functions ltl.X, ltl.F, ltl.G and ltl.U to represent temporal operators.
multiple formulas annotated with the same :live-property idx annotation (with the same index value) are considered multi-fairness constraints, and interpreted as FGp1 | ... | FGpn

how-to-convert:
How to convert chisel and systemVerilog to vmt?

Here is the case:
This is a simple chisel code:
```
class Memory(c: Int, w: Int) extends Module {
  val nw = log2Ceil(c)
  val io = IO(new Bundle {
    val wrEna = Input(Bool())
    val wrData = Input(UInt(w.W))
    val wrAddr = Input(UInt(nw.W))
    val rdAddr = Input(UInt(nw.W))
    val rdData = Output(UInt(w.W))
  })
  val mem = Mem(c, UInt(w.W))
  val a = true.B

  when(io.wrEna) {
    mem.write(io.wrAddr, io.wrData)
  }

  io.rdData := mem.read(io.rdAddr)
}
```
and this is the generated systemVerilog code, which is generated by Chisel compiler:
```
module Memory(
  input        clock,
  input        reset,
  input        io_wrEna,
  input  [7:0] io_wrData,
  input  [3:0] io_wrAddr,
  input  [3:0] io_rdAddr,
  output [7:0] io_rdData
);
`ifdef RANDOMIZE_MEM_INIT
  reg [31:0] _RAND_0;
`endif // RANDOMIZE_MEM_INIT
  reg [7:0] mem [0:15]; // @[Memory.scala 16:16]
  wire  mem_io_rdData_MPORT_en; // @[Memory.scala 16:16]
  wire [3:0] mem_io_rdData_MPORT_addr; // @[Memory.scala 16:16]
  wire [7:0] mem_io_rdData_MPORT_data; // @[Memory.scala 16:16]
  wire [7:0] mem_MPORT_data; // @[Memory.scala 16:16]
  wire [3:0] mem_MPORT_addr; // @[Memory.scala 16:16]
  wire  mem_MPORT_mask; // @[Memory.scala 16:16]
  wire  mem_MPORT_en; // @[Memory.scala 16:16]
  assign mem_io_rdData_MPORT_en = 1'h1;
  assign mem_io_rdData_MPORT_addr = io_rdAddr;
  assign mem_io_rdData_MPORT_data = mem[mem_io_rdData_MPORT_addr]; // @[Memory.scala 16:16]
  assign mem_MPORT_data = io_wrData;
  assign mem_MPORT_addr = io_wrAddr;
  assign mem_MPORT_mask = 1'h1;
  assign mem_MPORT_en = io_wrEna;
  assign io_rdData = mem_io_rdData_MPORT_data; // @[Memory.scala 23:13]
  always @(posedge clock) begin
    if (mem_MPORT_en & mem_MPORT_mask) begin
      mem[mem_MPORT_addr] <= mem_MPORT_data; // @[Memory.scala 16:16]
    end
  end
// Register and memory initialization
`ifdef RANDOMIZE_GARBAGE_ASSIGN
`define RANDOMIZE
`endif
`ifdef RANDOMIZE_INVALID_ASSIGN
`define RANDOMIZE
`endif
`ifdef RANDOMIZE_REG_INIT
`define RANDOMIZE
`endif
`ifdef RANDOMIZE_MEM_INIT
`define RANDOMIZE
`endif
`ifndef RANDOM
`define RANDOM $random
`endif
`ifdef RANDOMIZE_MEM_INIT
  integer initvar;
`endif
`ifndef SYNTHESIS
`ifdef FIRRTL_BEFORE_INITIAL
`FIRRTL_BEFORE_INITIAL
`endif
initial begin
  `ifdef RANDOMIZE
    `ifdef INIT_RANDOM
      `INIT_RANDOM
    `endif
    `ifndef VERILATOR
      `ifdef RANDOMIZE_DELAY
        #`RANDOMIZE_DELAY begin end
      `else
        #0.002 begin end
      `endif
    `endif
`ifdef RANDOMIZE_MEM_INIT
  _RAND_0 = {1{`RANDOM}};
  for (initvar = 0; initvar < 16; initvar = initvar+1)
    mem[initvar] = _RAND_0[7:0];
`endif // RANDOMIZE_MEM_INIT
  `endif // RANDOMIZE
end // initial
`ifdef FIRRTL_AFTER_INITIAL
`FIRRTL_AFTER_INITIAL
`endif
`endif // SYNTHESIS
endmodule

```

Here is a simple Verilog case:
```
module Memory(
  input        clock,
  input  [7:0] read_addr,
  input  [7:0] write_addr,
  input  [7:0] data_in,
  output [7:0] data_out
);
  reg [0:7] mem[0:255];
  assign data_out = mem[read_addr];
  always @(posedge clock) begin
    mem[write_addr] <= data_in;
  end
endmodule

```

and this is the generated vmt code, which is generated by yosys and I modified it a little bit:
```
(declare-const data_in (_ BitVec 8)) ; data_in:  8'0..8'255
(declare-const data_in.next (_ BitVec 8)) ; data_in:  8'0..8'255
(define-fun sv.data_in () (_ BitVec 8) (!
  data_in
:next data_in.next
))

(declare-const mem (Array (_ BitVec 8) (_ BitVec 8))); mem: [8'0..8'255][8'0..8'255]
(declare-const mem.next (Array (_ BitVec 8) (_ BitVec 8))); mem: [8'0..8'255][8'0..8'255]
(define-fun sv.mem () (Array (_ BitVec 8) (_ BitVec 8)) (!
  mem
  :next mem.next
))

(declare-const read_addr (_ BitVec 8)) ; read_addr: state -> 8'0..8'255
(declare-const read_addr.next (_ BitVec 8)) ; read_addr: state -> 8'0..8'255
(define-fun sv.read_addr () (_ BitVec 8) (!
  read_addr
  :next read_addr.next
))

(define-fun get_read_addr () (_ BitVec 8) (read_addr))


(define-fun data_out () (_ BitVec 8) (select mem get_read_addr)) ; data_out(state) = mem(state)[read_addr(state)]

(declare-const write_addr (_ BitVec 8)) ; write_addr: state -> 8'0..8'255
(declare-const write_addr.next (_ BitVec 8)) ; write_addr: state -> 8'0..8'255
(define-fun sv.write_addr () (_ BitVec 8) (!
  write_addr
  :next write_addr.next
))

(define-fun get_write_addr () (_ BitVec 8) (write_addr)) ; get_write_addr(state) = write_addr(state)

(define-fun get_data_in () (_ BitVec 8) (data_in)) ; get_data_in(state) = data_in(state)

(define-fun const_1 () (_ BitVec 8) (#b11111111)) ; const_1(state) = 8'255

(define-fun update_mem () (Array (_ BitVec 8) (_ BitVec 8))
  (ite (= (const_1) #b00000000)
    (mem)
    (store (mem) (get_write_addr state)
      (bvor
        (bvand (get_data_in) (const_1))
        (bvand
          (select (mem) (get_write_addr))
          (bvnot (const_1))
        ) ; 0
      ) ; data_in
    )
  )
) ; update_mem(state) = ite(const_1(state) = 8'0, mem(state), store(mem(state), get_write_addr(state), (get_data_in(state) & const_1(state)) | (mem(state)[get_write_addr(state)] & ~const_1(state))))

; Transition System

(define-fun init () Bool (!
  (forall ((addr (_ BitVec 8)))
    (= (select mem addr) #b00000000)
  ) :init true
)) ; init

(define-fun trans () Bool (!
  (= mem.next (update_mem))
  :trans true
)) ; trans() = (mem(state0.next) = update_mem(state0))
```
And we can add some properties to the vmt code:
```
; mem property save & read
(declare-const select_addr Int)
(declare-const select_addr.next Int)
(define-fun sv.select_addr () Int (!
  select_addr
  :next select_addr.next
))


(define-fun select_addr_trans () Bool (!
  (= select_addr.next (select_addr))
  :trans true
))

(declare-const data_check (_ BitVec 8))
(declare-const data_check.next (_ BitVec 8))
(define-fun sv.data_check () (_ BitVec 8) (!
  data_check
  :next data_check.next
))

(define-fun data_check_init () Bool (!
  (= data_check #b00000000)
  :init true
))

(define-fun data_check_trans () Bool (!
  (=
    data_check.next
    (ite (= get_write_addr select_addr)
      data_in
      data_check
    )
  )
  :trans true
))

(define-fun data_check_prop () Bool (!
  (and
      (or
        (not (= (get_read_addr) (select_addr state0)))
        (= data_out data_check)
      )
      (
        = data_check (select mem select_addr)
      )
        true
  )
  :invar-property 1
))
```

Use the vmt code and properties, we can use the model checking tools to verify the properties.


Your task is help user to verify hardware designs. User will tell you the design in Chisel
            or SystemVerilog format, and you can call the parser tool to convert it to VMT format.
            Then user can tell you the property to verify, and you need to add the property to the VMT content.
            Finally, you can call the model checking tool to verify the design with the property.
