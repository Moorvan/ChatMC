How to convert chisel and systemVerilog to vmt?

Here is the case:
This is a simple chisel code:
```
class Memory(c: Int, w: Int) extends Module {
  val nw = log2Ceil(c)
  val io = IO(new Bundle {
    val wrEna = Input(Bool())
    val wrData = Input(UInt(w.W))
    val wrAddr = Input(UInt(nw.W))
    val rdAddr = Input(UInt(nw.W))
    val rdData = Output(UInt(w.W))
  })
  val mem = Mem(c, UInt(w.W))
  val a = true.B

  when(io.wrEna) {
    mem.write(io.wrAddr, io.wrData)
  }

  io.rdData := mem.read(io.rdAddr)
}
```
and this is the generated systemVerilog code, which is generated by Chisel compiler:
```
module Memory(
  input        clock,
  input        reset,
  input        io_wrEna,
  input  [7:0] io_wrData,
  input  [3:0] io_wrAddr,
  input  [3:0] io_rdAddr,
  output [7:0] io_rdData
);
`ifdef RANDOMIZE_MEM_INIT
  reg [31:0] _RAND_0;
`endif // RANDOMIZE_MEM_INIT
  reg [7:0] mem [0:15]; // @[Memory.scala 16:16]
  wire  mem_io_rdData_MPORT_en; // @[Memory.scala 16:16]
  wire [3:0] mem_io_rdData_MPORT_addr; // @[Memory.scala 16:16]
  wire [7:0] mem_io_rdData_MPORT_data; // @[Memory.scala 16:16]
  wire [7:0] mem_MPORT_data; // @[Memory.scala 16:16]
  wire [3:0] mem_MPORT_addr; // @[Memory.scala 16:16]
  wire  mem_MPORT_mask; // @[Memory.scala 16:16]
  wire  mem_MPORT_en; // @[Memory.scala 16:16]
  assign mem_io_rdData_MPORT_en = 1'h1;
  assign mem_io_rdData_MPORT_addr = io_rdAddr;
  assign mem_io_rdData_MPORT_data = mem[mem_io_rdData_MPORT_addr]; // @[Memory.scala 16:16]
  assign mem_MPORT_data = io_wrData;
  assign mem_MPORT_addr = io_wrAddr;
  assign mem_MPORT_mask = 1'h1;
  assign mem_MPORT_en = io_wrEna;
  assign io_rdData = mem_io_rdData_MPORT_data; // @[Memory.scala 23:13]
  always @(posedge clock) begin
    if (mem_MPORT_en & mem_MPORT_mask) begin
      mem[mem_MPORT_addr] <= mem_MPORT_data; // @[Memory.scala 16:16]
    end
  end
// Register and memory initialization
`ifdef RANDOMIZE_GARBAGE_ASSIGN
`define RANDOMIZE
`endif
`ifdef RANDOMIZE_INVALID_ASSIGN
`define RANDOMIZE
`endif
`ifdef RANDOMIZE_REG_INIT
`define RANDOMIZE
`endif
`ifdef RANDOMIZE_MEM_INIT
`define RANDOMIZE
`endif
`ifndef RANDOM
`define RANDOM $random
`endif
`ifdef RANDOMIZE_MEM_INIT
  integer initvar;
`endif
`ifndef SYNTHESIS
`ifdef FIRRTL_BEFORE_INITIAL
`FIRRTL_BEFORE_INITIAL
`endif
initial begin
  `ifdef RANDOMIZE
    `ifdef INIT_RANDOM
      `INIT_RANDOM
    `endif
    `ifndef VERILATOR
      `ifdef RANDOMIZE_DELAY
        #`RANDOMIZE_DELAY begin end
      `else
        #0.002 begin end
      `endif
    `endif
`ifdef RANDOMIZE_MEM_INIT
  _RAND_0 = {1{`RANDOM}};
  for (initvar = 0; initvar < 16; initvar = initvar+1)
    mem[initvar] = _RAND_0[7:0];
`endif // RANDOMIZE_MEM_INIT
  `endif // RANDOMIZE
end // initial
`ifdef FIRRTL_AFTER_INITIAL
`FIRRTL_AFTER_INITIAL
`endif
`endif // SYNTHESIS
endmodule

```

Here is a simple Verilog case:
```
module Memory(
  input        clock,
  input  [7:0] read_addr,
  input  [7:0] write_addr,
  input  [7:0] data_in,
  output [7:0] data_out
);
  reg [0:7] mem[0:255];
  assign data_out = mem[read_addr];
  always @(posedge clock) begin
    mem[write_addr] <= data_in;
  end
endmodule

```

and this is the generated vmt code, which is generated by yosys and I modified it a little bit:
```
(declare-const data_in (_ BitVec 8)) ; data_in:  8'0..8'255
(declare-const data_in.next (_ BitVec 8)) ; data_in:  8'0..8'255
(define-fun sv.data_in () (_ BitVec 8) (!
  data_in
:next data_in.next
))

(declare-const mem (Array (_ BitVec 8) (_ BitVec 8))); mem: [8'0..8'255][8'0..8'255]
(declare-const mem.next (Array (_ BitVec 8) (_ BitVec 8))); mem: [8'0..8'255][8'0..8'255]
(define-fun sv.mem () (Array (_ BitVec 8) (_ BitVec 8)) (!
  mem
  :next mem.next
))

(declare-const read_addr (_ BitVec 8)) ; read_addr: state -> 8'0..8'255
(declare-const read_addr.next (_ BitVec 8)) ; read_addr: state -> 8'0..8'255
(define-fun sv.read_addr () (_ BitVec 8) (!
  read_addr
  :next read_addr.next
))

(define-fun get_read_addr () (_ BitVec 8) (read_addr))


(define-fun data_out () (_ BitVec 8) (select mem get_read_addr)) ; data_out(state) = mem(state)[read_addr(state)]

(declare-const write_addr (_ BitVec 8)) ; write_addr: state -> 8'0..8'255
(declare-const write_addr.next (_ BitVec 8)) ; write_addr: state -> 8'0..8'255
(define-fun sv.write_addr () (_ BitVec 8) (!
  write_addr
  :next write_addr.next
))

(define-fun get_write_addr () (_ BitVec 8) (write_addr)) ; get_write_addr(state) = write_addr(state)

(define-fun get_data_in () (_ BitVec 8) (data_in)) ; get_data_in(state) = data_in(state)

(define-fun const_1 () (_ BitVec 8) (#b11111111)) ; const_1(state) = 8'255

(define-fun update_mem () (Array (_ BitVec 8) (_ BitVec 8))
  (ite (= (const_1) #b00000000)
    (mem)
    (store (mem) (get_write_addr state)
      (bvor
        (bvand (get_data_in) (const_1))
        (bvand
          (select (mem) (get_write_addr))
          (bvnot (const_1))
        ) ; 0
      ) ; data_in
    )
  )
) ; update_mem(state) = ite(const_1(state) = 8'0, mem(state), store(mem(state), get_write_addr(state), (get_data_in(state) & const_1(state)) | (mem(state)[get_write_addr(state)] & ~const_1(state))))

; Transition System

(define-fun init () Bool (!
  (forall ((addr (_ BitVec 8)))
    (= (select mem addr) #b00000000)
  ) :init true
)) ; init

(define-fun trans () Bool (!
  (= mem.next (update_mem))
  :trans true
)) ; trans() = (mem(state0.next) = update_mem(state0))
```
And we can add some properties to the vmt code:
```
; mem property save & read
(declare-const select_addr Int)
(declare-const select_addr.next Int)
(define-fun sv.select_addr () Int (!
  select_addr
  :next select_addr.next
))


(define-fun select_addr_trans () Bool (!
  (= select_addr.next (select_addr))
  :trans true
))

(declare-const data_check (_ BitVec 8))
(declare-const data_check.next (_ BitVec 8))
(define-fun sv.data_check () (_ BitVec 8) (!
  data_check
  :next data_check.next
))

(define-fun data_check_init () Bool (!
  (= data_check #b00000000)
  :init true
))

(define-fun data_check_trans () Bool (!
  (=
    data_check.next
    (ite (= get_write_addr select_addr)
      data_in
      data_check
    )
  )
  :trans true
))

(define-fun data_check_prop () Bool (!
  (and
      (or
        (not (= (get_read_addr) (select_addr state0)))
        (= data_out data_check)
      )
      (
        = data_check (select mem select_addr)
      )
        true
  )
  :invar-property 1
))
```

Use the vmt code and properties, we can use the model checking tools to verify the properties.

Now you need to convert the chisel or systemVerilog code to vmt code, and add some properties to the vmt code
And you can use the model checking tools to verify the properties.
